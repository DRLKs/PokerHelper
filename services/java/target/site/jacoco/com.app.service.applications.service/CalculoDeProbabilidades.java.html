<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CalculoDeProbabilidades.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Poker Helper - Probability Service</a> &gt; <a href="index.source.html" class="el_package">com.app.service.applications.service</a> &gt; <span class="el_source">CalculoDeProbabilidades.java</span></div><h1>CalculoDeProbabilidades.java</h1><pre class="source lang-java linenums">package com.app.service.applications.service;

/*
 * MADE BY DRLK
 */
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.app.service.applications.service.Decision;
import com.app.service.domain.model.Carta;

<span class="fc" id="L12">public class CalculoDeProbabilidades {</span>
	/*
	 * Todas las probabilidades son sobre 1
	 */
	private double probPareja;
	private double probTrio;
	private double probEscalera;
	private double probColor;
	private double probFullHouse;
	private double probPoker;
	private double probEscaleraColor;
	private double probEscaleraReal;
	
	private double probParejaCont;
	private double probTrioCont;
	private double probEscaleraCont;
	private double probColorCont;
	private double probFullHouseCont;
	private double probPokerCont;
	private double probEscaleraColorCont;
	private double probEscaleraRealCont;
	
	/**
	 * Esta variable definirá la decisión que debe tomar el jugador&lt;br&gt; 
	 */
	private Decision decision;
	
	/**
	 * El número máximo de cartas que podemos ver al mismo tiempo son 7
	 */
<span class="fc" id="L42">	private final int MAX_CARTAS_VISIBLES = 7;</span>
	/**
	 * El número de cartas que tienen el mismo número es 4
	 */
<span class="fc" id="L46">	private final int MAX_CARTAS_NUMERO = 4;</span>
<span class="fc" id="L47">	private final int IDX_CARTA_MANO_1 = 0;</span>
<span class="fc" id="L48">	private final int IDX_CARTA_MANO_2 = 1;</span>
	/**
	 * 45
	 */
<span class="fc" id="L52">	private final int NUM_CARTAS_NUNCA_VES = 45;</span>

	/**
	 * Función que recalcula todas las probabilidades
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @param numContrincantes Número de contrincantes activos
	 * @param ciegaPequenya Valor de la ciega pequenya de la mano
	 * @param apuestaAcumulada Valor de la apuesta acumulada en la mano
	 */
	public void reiniciarDatos( List&lt;Carta&gt; cartas, int numContrincantes, int ciegaPequenya, int apuestaAcumulada) {
<span class="fc" id="L63">		probPareja = completarPareja(cartas);</span>
<span class="fc" id="L64">		probTrio = completarTrio(cartas);</span>
<span class="fc" id="L65">		probEscalera = completarEscalera(cartas);</span>
<span class="fc" id="L66">		probColor = completarColor(cartas);</span>
<span class="fc" id="L67">		probFullHouse = completarFullHouse(cartas);</span>
<span class="fc" id="L68">		probPoker = completarPoker(cartas);</span>
<span class="fc" id="L69">		probEscaleraColor = completarEscaleraColor(cartas);</span>
<span class="fc" id="L70">		probEscaleraReal = completarEscaleraReal(cartas);</span>
		
<span class="fc" id="L72">		completarParejaTrioPokerCont(cartas, numContrincantes);</span>
<span class="fc" id="L73">		probEscaleraCont = completarEscaleraCont(cartas, numContrincantes);</span>
<span class="fc" id="L74">		probColorCont = completarColorCont( cartas, numContrincantes );</span>
<span class="fc" id="L75">		probFullHouseCont = completarFullHouseCont(cartas, numContrincantes);</span>
<span class="fc" id="L76">		probEscaleraColorCont = completarEscaleraColorCont(cartas, numContrincantes);</span>
<span class="fc" id="L77">		probEscaleraRealCont = completarEscaleraRealCont(cartas, numContrincantes);</span>
		
<span class="fc" id="L79">		decision = calcularDecision(ciegaPequenya, apuestaAcumulada);</span>

		/*
		try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println(&quot;Esperando conexión de Python...&quot;);
            Socket clientSocket = serverSocket.accept();
            System.out.println(&quot;Conexión establecida con Python&quot;);


            // Enviar los datos a Python
            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
            // MIAS
            out.println(probEscalera);
            out.println(probColor);
            out.println(probFullHouse);
            out.println(probPoker);
            out.println(probEscaleraColor);
            out.println(probEscaleraReal);
            // DE LOS CONTRINCANTES
            out.println(probEscaleraCont);
            out.println(probColorCont);
            out.println(probFullHouseCont);
            out.println(probPokerCont);
            out.println(probEscaleraColorCont);
            out.println(probEscaleraRealCont);

            System.out.println(&quot;Datos enviados a Python&quot;);

            // Cerrar la conexión
            out.close();
            clientSocket.close();
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        */
<span class="fc" id="L115">    }</span>

	/*
	 * ##############################################################################################################
	 * 												GETTERS 
	 * ##############################################################################################################
	 */

	public double getProbPareja() {
<span class="nc" id="L124">		return probPareja;</span>
	}
	
	public double getProbTrio() {
<span class="nc" id="L128">		return probTrio;</span>
	}
	
	public double getProbEscalera() {
<span class="nc" id="L132">		return probEscalera;</span>
	}

	public double getProbColor() {
<span class="nc" id="L136">		return probColor;</span>
	}

	public double getProbFullHouse() {
<span class="nc" id="L140">		return probFullHouse;</span>
	}

	public double getProbPoker() {
<span class="nc" id="L144">		return probPoker;</span>
	}

	public double getProbEscaleraColor() {
<span class="nc" id="L148">		return probEscaleraColor;</span>
	}

	public double getProbEscaleraReal() {
<span class="nc" id="L152">		return probEscaleraReal;</span>
	}
	

	public double getProbParejaCont() {
<span class="nc" id="L157">		return probParejaCont;</span>
	}
	
	public double getProbTrioCont() {
<span class="nc" id="L161">		return probTrioCont;</span>
	}
	
	public double getProbColorCont() {
<span class="nc" id="L165">		return probColorCont;</span>
	}
	
	public double getProbEscaleraCont() {
<span class="nc" id="L169">		return probEscaleraCont;</span>
	}

	public double getProbFullHouseCont() {
<span class="nc" id="L173">		return probFullHouseCont;</span>
	}


	public double getProbPokerCont() {
<span class="nc" id="L178">		return probPokerCont;</span>
	}
	
	public double getProbEscaleraColorCont() {
<span class="nc" id="L182">		return probEscaleraColorCont;</span>
	}

	public double getProbEscaleraRealCont() {
<span class="nc" id="L186">		return probEscaleraRealCont;</span>
	}

	public Decision getDecision() {
<span class="fc" id="L190">		return decision;</span>
	}

	public void setDecision(Decision decision) {
<span class="nc" id="L194">		this.decision = decision;</span>
<span class="nc" id="L195">	}</span>
	
	
	/**
	 * Función que devuelve las combinaciones entre 2 números
	 * 
	 * @param n Número de elementos en el conjunto
	 * @param k Número de combinaciones
	 * @return Número de combinaciones posibles
	 */
	public int C( int n ,int k) { // COMBINACIONES
		
<span class="fc bfc" id="L207" title="All 4 branches covered.">		if (k &gt; n || k &lt; 0) return -1; // No existe combinatoria si k &gt; n</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">        if (k == 0 || k == n ) return 1;</span>
        /* La combinación es simétrica, C(n, k) = C(n, n-k) */
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (k &gt; n - k) {</span>
<span class="fc" id="L211">            k = n - k;</span>
        }
<span class="fc" id="L213">        int ini = 1 + n - k; </span>
<span class="fc" id="L214">        int resultado = 1;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int i = ini; i &lt;= n; ++i) {</span>
<span class="fc" id="L216">            resultado *= i;</span>
        }
<span class="fc bfc" id="L218" title="All 2 branches covered.">        for(int i = 2 ; i &lt;= k ; ++i) {</span>
<span class="fc" id="L219">        	resultado /= i;</span>
        }

<span class="fc" id="L222">        return resultado;</span>
	}
	
	/*
	 * ##############################################################################################################
	 * 								FUNCIONES PARA CALCULAR NUESTRAS PROBABILIDADES
	 * ##############################################################################################################
	 */
	
	/** 
	 * Función que devuelve la probabilidad de obtener una pareja con las cartas que tenemos
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener una pareja con las cartas de nuestra mano (double)
	 * */
	private double completarPareja( List&lt;Carta&gt; cartas ) {
		
		double prob;

<span class="fc" id="L241">		int numCartas = cartas.size();</span>
<span class="fc" id="L242">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L243">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>

<span class="pc bpc" id="L245" title="1 of 2 branches missed.">		if( cartas.get(IDX_CARTA_MANO_1).mismoNumeroQue(cartas.get(IDX_CARTA_MANO_2)) ) {	/* Nuestras cartas hacen pareja */</span>
<span class="nc" id="L246">			prob = 1.0;</span>
		}else {					/* Nuestras cartas no hacen pareja */
			int num;
<span class="fc" id="L249">			prob = 0.0;</span>
			
<span class="fc bfc" id="L251" title="All 2 branches covered.">			for( int idxCartaMano = 0 ; idxCartaMano &lt; 2 ; ++idxCartaMano ) {</span>
<span class="fc" id="L252">				num = cartas.get(idxCartaMano).getNumero(); 	/* Número de nuestra carta */</span>
				
<span class="fc bfc" id="L254" title="All 2 branches covered.">				for( int idx = 2 ; idx &lt; numCartas ; idx++ ) {</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">					if( cartas.get(idx).getNumero() == num ) {	/* Encontramos carta en la mesa con el mismo número */</span>
<span class="nc" id="L256">						prob = 1.0;</span>
					}
				}
			}
			
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">			if( prob &lt;= 0.0 ) {	/* En el caso de que la probabilidad siga siendo 0.0, no hemos encontrado ninguna pareja */</span>
<span class="fc" id="L262">				prob += distribucionHiperGeometrica(1, MAX_CARTAS_NUMERO - 1, cartasTotales, cartasPorMostrar);</span>
			}
			
		}
<span class="fc" id="L266">		return prob;</span>
	}
	
	/** 
	 * Función que devuelve la probabilidad de obtener un trio con las cartas que tenemos
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener un trio con las cartas de nuestra mano (double)
	 * */
	private double completarTrio( List&lt;Carta&gt; cartas ) {
		
		double prob;
		int numCartasTrio;

<span class="fc" id="L280">		int numCartas = cartas.size();</span>
<span class="fc" id="L281">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L282">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>

<span class="pc bpc" id="L284" title="1 of 2 branches missed.">		if( cartas.get(IDX_CARTA_MANO_1).mismoNumeroQue(cartas.get(IDX_CARTA_MANO_2)) ) {	/* Nuestras cartas hacen pareja */</span>
<span class="nc" id="L285">			numCartasTrio = 2;</span>
<span class="nc" id="L286">			int num = cartas.get(IDX_CARTA_MANO_1).getNumero(); /* Número de nuestras cartas */</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">			for( int idx = 2 ; idx &lt; numCartas ; ++idx ) {</span>
				
<span class="nc bnc" id="L289" title="All 2 branches missed.">				if( cartas.get(idx).getNumero() == num ) {	/* Ya tenemos un trio */</span>
<span class="nc" id="L290">					numCartasTrio = 3;</span>
<span class="nc" id="L291">					break;</span>
				}
			}
<span class="nc" id="L294">			prob = distribucionHiperGeometrica(3 - numCartasTrio, MAX_CARTAS_NUMERO - numCartasTrio, cartasTotales, cartasPorMostrar);</span>
			
<span class="nc" id="L296">		}else {					/* Nuestras cartas no hacen pareja */</span>
			int num;
<span class="fc" id="L298">			prob = 0.0;</span>
			
<span class="fc bfc" id="L300" title="All 2 branches covered.">			for( int idxCartaMano = 0 ; idxCartaMano &lt; 2 ; ++idxCartaMano ) {</span>
<span class="fc" id="L301">				numCartasTrio = 1;</span>
<span class="fc" id="L302">				num = cartas.get(idxCartaMano).getNumero(); 	/* Número de nuestra carta */</span>
				
<span class="fc bfc" id="L304" title="All 2 branches covered.">				for( int idx = 2 ; idx &lt; numCartas ; idx++ ) {</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">					if( cartas.get(idx).getNumero() == num ) {	/* Encontramos carta en la mesa con el mismo número */</span>
<span class="nc" id="L306">						++numCartasTrio;</span>
					}
				}
				
<span class="fc" id="L310">				prob += distribucionHiperGeometrica(3 - numCartasTrio, MAX_CARTAS_NUMERO - numCartasTrio, cartasTotales, cartasPorMostrar);</span>

			}

		}
<span class="fc" id="L315">		return prob;</span>
	}
	
	/** 
	 * Función que devuelve la probabilidad de obtener color con las cartas que tenemos
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener color con las cartas de nuestra mano (double)
	 * */
	private double completarColor( List&lt;Carta&gt; cartas ){
		
		double prob;
<span class="fc" id="L327">		int numCartasColor = 1;</span>
<span class="fc" id="L328">		int numCartas = cartas.size();</span>
<span class="fc" id="L329">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L330">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
		int numCartasNecesarias;
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">		if( cartas.get(0).mismoPaloQue( cartas.get(1) ) ) {</span>
<span class="fc" id="L333">			++numCartasColor;</span>
			
<span class="fc bfc" id="L335" title="All 2 branches covered.">			for( int i = 2; i &lt; numCartas ; ++i ) {</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">				if( cartas.get(i).mismoPaloQue(cartas.get(0)) ) {</span>
<span class="fc" id="L337">					++numCartasColor;</span>
				}
			}
<span class="fc" id="L340">			numCartasNecesarias = 5-numCartasColor;</span>
<span class="fc" id="L341">			prob = distribucionHiperGeometrica(numCartasNecesarias, 13-numCartasColor, cartasTotales, cartasPorMostrar);</span>
		}else {
			
<span class="nc" id="L344">			prob = 0.0;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">			for( int idxCMano = 0 ; idxCMano &lt; 2 ; ++idxCMano ) {	</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">					for( int i = 2; i &lt; numCartas ; ++i ) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">						if( cartas.get(i).mismoPaloQue(cartas.get(idxCMano)) ) {</span>
<span class="nc" id="L348">							++numCartasColor;</span>
					}
				}
<span class="nc" id="L351">				numCartasNecesarias = 5 - numCartasColor;</span>
<span class="nc" id="L352">				prob += distribucionHiperGeometrica(numCartasNecesarias, 13-numCartasColor, cartasTotales, cartasPorMostrar);</span>
<span class="nc" id="L353">				numCartasColor = 1;</span>
			}
		}
<span class="fc" id="L356">		return prob;</span>
	}
	
	/**
	 * Función que devuelve la probabilidad de obtener escalera con las cartas que tenemos
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener escalera con las cartas de nuestra mano (double)
	 */
	private double completarEscalera( List&lt;Carta&gt; cartas ){
			
		double prob;
<span class="fc" id="L368">		int numCartas = cartas.size();</span>
<span class="fc" id="L369">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L370">		int numCartaMano1 = cartas.get(IDX_CARTA_MANO_1).getNumero();</span>
<span class="fc" id="L371">		int numCartaMano2 = cartas.get(IDX_CARTA_MANO_2).getNumero();</span>
		int arrayInicio;
		int arrayFinal;
		
		/*
		 * El array &quot;numerosEscalera&quot; tendrá un tamaño igual a 14
		 *  En este array podremos comprobar si tenemos un número, por ejemplo:
		 *  
		 *  Comprobamos que tenemos el AS -&gt; numerosEscalera[14] == 1
		 *  		TRUE -&gt; Tenemos el AS
		 *  		FALSE -&gt; No tenemos el AS
		 *  El AS al tener asociado el número 14, lo podremos comprobar en el lugar 14 y a la 1
		 *  No usaremos la posición 0
		 */
		int[] numerosEscalera;	
		int[] arrayFronterasEscalera;
		
		/* Nuestras 2 cartas pueden hacer escalera */
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">		if( cartas.get(0).puedenHacerEscalera( cartas.get(1) )) {	</span>
<span class="fc" id="L390">			numerosEscalera = new int[15];</span>
			
<span class="fc" id="L392">			numerosEscalera[ numCartaMano1 ] = 1;</span>
<span class="fc" id="L393">			numerosEscalera[ numCartaMano2 ] = 1;</span>
			
<span class="fc" id="L395">			arrayFronterasEscalera = encontrarFronterasEscaleras(numCartaMano1, numCartaMano2);</span>
<span class="fc" id="L396">			arrayInicio = arrayFronterasEscalera[0];</span>
<span class="fc" id="L397">			arrayFinal  = arrayFronterasEscalera[1];</span>
			
<span class="fc bfc" id="L399" title="All 2 branches covered.">			for( int idx = 2; idx &lt; numCartas ; ++idx ) {</span>
<span class="fc" id="L400">				numerosEscalera[ cartas.get(idx).getNumero() ] = 1;</span>
			}
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">			if( numerosEscalera[14] == 1 ) {	// Está el AS, 14-1=13</span>
<span class="fc" id="L403">				numerosEscalera[1] = 1;</span>
			}
<span class="fc" id="L405">			prob = probCompletarEscalera(numerosEscalera, cartasPorMostrar, arrayInicio, arrayFinal);</span>
		/* Nuestras 2 cartas no pueden hacer escalera */
		}else {	
<span class="nc" id="L408">			prob = 0.0;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">			for( int idxCMano = 0 ; idxCMano &lt; 2 ; ++idxCMano ) {	</span>
<span class="nc" id="L410">				numerosEscalera = new int[15];</span>
<span class="nc" id="L411">				numerosEscalera[ cartas.get(idxCMano).getNumero() ] = 1;	// Añadimos la carta de la mano</span>
<span class="nc" id="L412">				arrayFronterasEscalera = encontrarFronterasEscaleras(cartas.get(idxCMano).getNumero(), -1);</span>
<span class="nc" id="L413">				arrayInicio = arrayFronterasEscalera[0];</span>
<span class="nc" id="L414">				arrayFinal  = arrayFronterasEscalera[1];</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">				for( int idx = 2; idx &lt; numCartas ; ++idx ) {</span>
<span class="nc" id="L416">					if( </span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">						cartas.get(idxCMano).mismoPaloQue(cartas.get(idx))</span>
						) {
<span class="nc" id="L419">						numerosEscalera[ cartas.get(idx).getNumero() ] = 1;</span>
					}
<span class="nc bnc" id="L421" title="All 2 branches missed.">					if( numerosEscalera[14] == 1 ) {</span>
<span class="nc" id="L422">						numerosEscalera[1] = 1;</span>
					}
<span class="nc" id="L424">					prob += probCompletarEscalera(numerosEscalera, cartasPorMostrar, arrayInicio, arrayFinal);</span>
				}
			}
		}
<span class="fc" id="L428">		return prob;	</span>
		
	}
	
	/**
	 * Función auxiliar que ayuda a obtener la probabilidad de obtener una escalera con las cartas que tenemos
	 *
	 * @param numerosEscalera Array con los números de las cartas que tenemos
	 * @param cartasPorMostrar Número de cartas que faltan por mostrar
	 * @param arrayInicio Índice del array por el cual comenzaremos a estudiar la escalera (Frontera Por Debajo)
	 * @param arrayFinal Índice del array por el cual terminaremos de estudiar la escalera (Frontera Por Encima)
	 * @return Probabilidad de obtener escalera con una carta específica de nuestra mano (double)
	 */
	private double probCompletarEscalera( int[] numerosEscalera, int cartasPorMostrar, int arrayInicio, int arrayFinal ){
<span class="fc" id="L442">		double prob = 0.0;</span>
		int numCartasEscalera;
<span class="fc" id="L444">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">		for( int idx1 = arrayInicio ; idx1 &lt;= arrayFinal - 4 ; ++idx1 ) {</span>
<span class="fc" id="L446">			numCartasEscalera = 0;</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">			for( int idx = idx1 ; idx &lt;= idx1+4 ; ++idx) {</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">				if( numerosEscalera[idx] == 1 ) {</span>
<span class="fc" id="L449">					++numCartasEscalera;</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">					if( numCartasEscalera &gt;= 5 ) {</span>
<span class="fc" id="L451">						return 1.0;</span>
					}
				}
			}
<span class="fc" id="L455">			int cartasNecesarias = 5-numCartasEscalera;</span>
<span class="fc" id="L456">			prob += distribucionHiperGeometrica(cartasNecesarias, cartasNecesarias*4,cartasTotales, cartasPorMostrar);</span>
		}
<span class="nc" id="L458">		return prob;</span>
	}

	/**
	 * Función que devuelve la probabilidad de obtener un Full con las cartas que tenemos
	 *
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener un Full con las cartas de nuestra mano (double)
	 */
	private double completarFullHouse( List&lt;Carta&gt; cartas ) {	// Falta por completar
		
<span class="fc" id="L469">		int numCartas = cartas.size();</span>
<span class="fc" id="L470">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L471">		int numParejas = 0;	// Parejas que hacen las cartas de nuestra mano</span>
<span class="fc" id="L472">		int numTrios   = 0;	// Trios   que hacen las cartas de nuestra mano</span>
		
		int ctt;
		
		// Esta parte de la función calculamos el número de parejas o trios que tenemos con nuestras cartas
		// En el caso de que nuestras cartas sean iguales
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">		if( cartas.get(IDX_CARTA_MANO_1).mismoNumeroQue(cartas.get(IDX_CARTA_MANO_2)) ) {	</span>
<span class="nc" id="L479">			ctt = Carta.vecesQueSeSaleEsteNumero(cartas, cartas.get(IDX_CARTA_MANO_1).getNumero());</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">			if( ctt &gt; 2 ) {</span>
<span class="nc" id="L481">				++numTrios;</span>
			}else {
<span class="nc" id="L483">				++numParejas;</span>
			}
			
		// En el caso de que nuestas cartas no sean iguales
		}else {
<span class="fc bfc" id="L488" title="All 2 branches covered.">			for( int idx = 0 ; idx &lt; 2 ; ++idx ) {</span>
<span class="fc" id="L489">				ctt = Carta.vecesQueSeSaleEsteNumero(cartas, cartas.get(idx).getNumero());</span>
					
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">				if( ctt &gt; 2 ) {</span>
<span class="nc" id="L492">					++numTrios;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">				}else if( ctt == 2 ) {</span>
<span class="nc" id="L494">					++numParejas;</span>
				}	
			}
		}
		
		// Ya habriamos obtenido el FULL
<span class="pc bpc" id="L500" title="4 of 6 branches missed.">		if( numParejas &gt; 0 &amp;&amp; numTrios &gt; 0 || numTrios &gt; 1 ) {</span>
<span class="nc" id="L501">			return 1.0;</span>
			
		// Tenemos que estudiar más
		}else {
<span class="fc" id="L505">			int numParejasMesa = 0;</span>
<span class="fc" id="L506">			int numTriosMesa = 0;</span>
			Carta cartaAux;
<span class="fc bfc" id="L508" title="All 2 branches covered.">			for( int idx1 = 2 ; idx1 &lt; numCartas ; ++idx1 ) {</span>
<span class="fc" id="L509">				cartaAux = cartas.get(idx1);</span>
<span class="pc bpc" id="L510" title="2 of 4 branches missed.">				if( !cartaAux.mismoNumeroQue(cartas.get(IDX_CARTA_MANO_1)) &amp;&amp; !cartaAux.mismoNumeroQue(cartas.get(IDX_CARTA_MANO_2)) ) {</span>
<span class="fc" id="L511">					ctt = 0;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">					for( int idx = idx1 + 1 ; idx &lt; numCartas ; ++idx ) {</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">						if( cartaAux.mismoNumeroQue(cartas.get(idx)) ) {</span>
<span class="nc" id="L514">							++ctt;</span>
						}
					}
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">					if( ctt == 2 ) {</span>
<span class="nc" id="L518">						++numParejasMesa;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">					}else if( ctt &gt; 2 ) {</span>
<span class="nc" id="L520">						++numTriosMesa;</span>
					}
				}
			}
<span class="fc" id="L524">			return probCompletarFullHouse(cartasPorMostrar,  numParejas , numTrios, numParejasMesa, numTriosMesa);</span>
		}
	}

	/**
	 * Función auxiliar que ayuda a obtener la probabilidad de tener un Full con las cartas que tenemos
	 *
	 * @return Probabilidad de obtener una escalera de color con las cartas de nuestra mano (double)
	 */
	private double probCompletarFullHouse( int cartasPorMostrar, int numParejas, int numTrios, int numParejasMesa, int numTriosMesa ){	
		
		double prob;
		
		/* Ya tendriamos el poker */
<span class="pc bpc" id="L538" title="9 of 12 branches missed.">		if( numParejas &gt; 0 &amp;&amp; numTriosMesa &gt; 0 || numTrios &gt; 0 &amp;&amp; numParejasMesa &gt; 0 || numTrios &gt; 0 &amp;&amp; numTriosMesa &gt; 0 ) {</span>
<span class="nc" id="L539">			prob =  1.0;</span>
		}else {
		/* Debemos seguir estudiandolo */	
<span class="fc" id="L542">			prob = 0.0;</span>
<span class="fc" id="L543">			int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">			if( numTriosMesa &gt; 0) {</span>
				/* Necesitariamos una sola carta de la mano, para hacer el FULL*/
<span class="nc" id="L546">				prob += distribucionHiperGeometrica(1, (MAX_CARTAS_NUMERO - 1) * 2,cartasTotales, cartasPorMostrar);	</span>
			}
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">			else if( numTrios &gt; 0 ) {</span>
				/* Necesitariamos 1 carta más de las que hay en la mesa para obtener el FULL*/
<span class="nc" id="L550">				prob += distribucionHiperGeometrica(1, (MAX_CARTAS_VISIBLES - cartasPorMostrar) * 3,cartasTotales, cartasPorMostrar);</span>
				/* Necesitamos 2 cartas más de las que no han salido en la mesa */
<span class="nc" id="L552">				prob += distribucionHiperGeometrica(2, MAX_CARTAS_NUMERO ,cartasTotales, cartasPorMostrar);</span>
			}
			
<span class="pc bpc" id="L555" title="3 of 4 branches missed.">			if( numParejas &gt; 0 &amp;&amp; numParejas + numParejasMesa &gt; 1 ){</span>
				/* Necesitamos una carta de alguna de las parejas para formar un trio */
<span class="nc" id="L557">				prob += distribucionHiperGeometrica(1, numParejas * 2 + numParejasMesa * 2,cartasTotales, cartasPorMostrar);</span>
				/* Necesitamos 3 cartas más de algun número que no ha salido todavía */
<span class="nc" id="L559">				prob += distribucionHiperGeometrica(3, MAX_CARTAS_NUMERO,cartasTotales, cartasPorMostrar);</span>
			}
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">			else if( numParejas &gt; 0 ) {</span>
				/* Necesitamos 2 cartas de alguna de las cartas de las cartas */
<span class="nc" id="L563">				prob += distribucionHiperGeometrica(2, (MAX_CARTAS_VISIBLES - cartasPorMostrar - 2) * 3,cartasTotales, cartasPorMostrar);</span>
				/* Necesitamos 3 cartas de las que no han salido todavia */
<span class="nc" id="L565">				prob += distribucionHiperGeometrica(3, MAX_CARTAS_NUMERO,cartasTotales, cartasPorMostrar);</span>
			}else {
				/* Obtener pareja y trio de las cartas de nuestra mano */
<span class="fc" id="L568">				prob += distribucionHiperGeometrica(3, 6,cartasTotales, cartasPorMostrar);</span>
			}
			
		}
<span class="fc" id="L572">		return prob;</span>
	}
	
	/**
	 * Función que devuelve la probabilidad de obtener Poker con las cartas que tenemos
	 *
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener Poker con las cartas de nuestra mano (double)
	 */
	private double completarPoker( List&lt;Carta&gt; cartas ) {
		
		double prob;
		
<span class="fc" id="L585">		int numCartas = cartas.size();</span>
<span class="fc" id="L586">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L587">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
		int cttCartasPoker;
		int numCartasNecesarias;
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">		if( cartas.get(0).mismoNumeroQue( cartas.get(1) ) ) {</span>
<span class="nc" id="L591">			cttCartasPoker = 2;</span>
			
<span class="nc bnc" id="L593" title="All 2 branches missed.">			for(  int idx = 2 ; idx &lt; numCartas ; ++idx ) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">				if(cartas.get(0).mismoNumeroQue(cartas.get(idx))) {</span>
<span class="nc" id="L595">					++cttCartasPoker;</span>
				}
			}
<span class="nc" id="L598">			numCartasNecesarias = MAX_CARTAS_NUMERO - cttCartasPoker;</span>
<span class="nc" id="L599">			prob = distribucionHiperGeometrica(numCartasNecesarias, numCartasNecesarias, cartasTotales, cartasPorMostrar);</span>
		}else {
<span class="fc" id="L601">			prob = 0.0;</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">			for(  int idxCarta = 0 ; idxCarta &lt; 2 ; ++idxCarta ) {</span>
<span class="fc" id="L603">				cttCartasPoker = 1;</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">				for( int idx = 2 ; idx &lt; numCartas ; ++idx ) {</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">					if(cartas.get(idxCarta).mismoNumeroQue(cartas.get(idx))) {</span>
<span class="nc" id="L606">						++cttCartasPoker;</span>
					}
				}
<span class="fc" id="L609">				numCartasNecesarias = MAX_CARTAS_NUMERO - cttCartasPoker;</span>
<span class="fc" id="L610">				prob += distribucionHiperGeometrica(numCartasNecesarias, numCartasNecesarias,cartasTotales, cartasPorMostrar);</span>
			}
			
		}
		
<span class="fc" id="L615">		return prob;</span>
	}
	
	/**
	 * Función que devuelve la probabilidad de obtener escalera de color con las cartas que tenemos
	 *
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener una escalera de color con las cartas de nuestra mano (double)
	 */
	private double completarEscaleraColor( List&lt;Carta&gt; cartas ){
		
<span class="fc" id="L626">		double prob = 0.0;</span>
<span class="fc" id="L627">		int numCartas = cartas.size();</span>
<span class="fc" id="L628">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L629">		int numCartaMano1 = cartas.get(IDX_CARTA_MANO_1).getNumero();</span>
<span class="fc" id="L630">		int numCartaMano2 = cartas.get(IDX_CARTA_MANO_2).getNumero();</span>
		int arrayInicio;
		int arrayFinal;
		
		/*
		 * El array &quot;numerosEscaleraColor&quot; tendrá un tamaño igual a 14
		 *  En este array podremos comprobar si tenemos un número, por ejemplo:
		 *  
		 *  Comprobamos que tenemos el AS -&gt; numerosEscaleraColor[14] == 1
		 *  		TRUE -&gt; Tenemos el AS
		 *  		FALSE -&gt; No tenemos el AS
		 *  El AS al tener asociado el número 14, lo podremos comprobar en el lugar 14 y a la 1
		 *  No usaremos la posición 0
		 */
		int[] numerosEscaleraColor;	
		int[] arrayFronterasEscalera;
		
		// Nuestras 2 pueden hacer escalera color
<span class="pc bpc" id="L648" title="2 of 4 branches missed.">		if( cartas.get(0).puedenHacerEscalera( cartas.get(1) ) &amp;&amp;  cartas.get(0).mismoPaloQue( cartas.get(1))) {	</span>
<span class="fc" id="L649">			numerosEscaleraColor = new int[15];</span>
			
<span class="fc" id="L651">			numerosEscaleraColor[ numCartaMano1 ] = 1;</span>
<span class="fc" id="L652">			numerosEscaleraColor[ numCartaMano2 ] = 1;</span>
			
<span class="fc" id="L654">			arrayFronterasEscalera = encontrarFronterasEscaleras(numCartaMano1, numCartaMano2);</span>
<span class="fc" id="L655">			arrayInicio = arrayFronterasEscalera[0];</span>
<span class="fc" id="L656">			arrayFinal  = arrayFronterasEscalera[1];</span>
			
<span class="fc bfc" id="L658" title="All 2 branches covered.">			for( int idx = 2; idx &lt; numCartas ; ++idx ) {</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">				if( cartas.get(0).mismoPaloQue(cartas.get(idx)) ) {		// Que no puedan hacer escalera no importa, se filtra luego</span>
<span class="fc" id="L660">					numerosEscaleraColor[ cartas.get(idx).getNumero() ] = 1;</span>
				}
			}
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">			if( numerosEscaleraColor[14] == 1 ) {	// Está el AS, 14-1=13</span>
<span class="fc" id="L664">				numerosEscaleraColor[1] = 1;</span>
			}
<span class="fc" id="L666">			prob = probCompletarEscaleraColor(numerosEscaleraColor, cartasPorMostrar, arrayInicio, arrayFinal);</span>
			
		}else {	// Nuestras 2 cartas no pueden hacer escalera de color entre ellas
<span class="nc bnc" id="L669" title="All 2 branches missed.">			for( int idxCMano = 0 ; idxCMano &lt; 2 ; ++idxCMano ) {	</span>
<span class="nc" id="L670">				numerosEscaleraColor = new int[15];</span>
<span class="nc" id="L671">				numerosEscaleraColor[ cartas.get(idxCMano).getNumero() ] = 1;	// Añadimos la carta de la mano</span>
<span class="nc" id="L672">				arrayFronterasEscalera = encontrarFronterasEscaleras(cartas.get(idxCMano).getNumero(), -1);</span>
<span class="nc" id="L673">				arrayInicio = arrayFronterasEscalera[0];</span>
<span class="nc" id="L674">				arrayFinal  = arrayFronterasEscalera[1];</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">				for( int idx = 2; idx &lt; numCartas ; ++idx ) {</span>
<span class="nc" id="L676">					if( </span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">						cartas.get(idxCMano).mismoPaloQue(cartas.get(idx))</span>
						) {
<span class="nc" id="L679">						numerosEscaleraColor[ cartas.get(idx).getNumero() ] = 1;</span>
					}
<span class="nc bnc" id="L681" title="All 2 branches missed.">					if( numerosEscaleraColor[14] == 1 ) {	// Está el AS, 14-1=13</span>
<span class="nc" id="L682">						numerosEscaleraColor[1]  =  1;</span>
					}
<span class="nc" id="L684">					prob += probCompletarEscaleraColor(numerosEscaleraColor, cartasPorMostrar, arrayInicio, arrayFinal);</span>
				}
			}
		}
		
<span class="fc" id="L689">		return prob;</span>
	}
	/**
	 * Función utilizada por las funciones: completarEscalera, completarEscaleraColor. Lo que hace esta función es determinar 
	 * los valores que debemos analizar para la obtención de la probabilidad de conseguir escaleras
	 *  
	 * @param numCarta1 Número de la carta
	 * @param numCarta2 Número de la segunda carta o -1 para indicar que solo tenemos una
	 * @return Un array de dimensión 2, donde en la primera posición nos encontramos el límite inferior y en la segunda el límite superior
	 */
	private int[] encontrarFronterasEscaleras( int numCarta1, int numCarta2 ) {
<span class="fc" id="L700">		int[] arrayFronterasEscalera = new int[2];</span>
		int arrayFinal;
		int arrayInicio;
<span class="pc bpc" id="L703" title="3 of 4 branches missed.">		if( numCarta1 == 14 || numCarta2 == 14 ) {	// se puede optimizar</span>
<span class="fc" id="L704">			arrayInicio = 1;</span>
<span class="fc" id="L705">			arrayFinal = 14;</span>
		}else {
		
<span class="nc" id="L708">			arrayInicio = numCarta1 - 4;</span>
<span class="nc bnc" id="L709" title="All 4 branches missed.">			if( numCarta2 != -1 &amp;&amp; arrayInicio &lt; numCarta2 - 4 ) {</span>
<span class="nc" id="L710">				arrayInicio = numCarta2 - 4;</span>
<span class="nc" id="L711">				arrayFinal = numCarta2 + 4;</span>
			}else {
<span class="nc" id="L713">				arrayFinal = numCarta1 + 4;</span>
			}
<span class="nc bnc" id="L715" title="All 2 branches missed.">			if( arrayFinal &gt; 14 ) {</span>
<span class="nc" id="L716">				arrayFinal = 14;</span>
			}
<span class="nc bnc" id="L718" title="All 2 branches missed.">			if( arrayInicio &lt; 1 ) {</span>
<span class="nc" id="L719">				arrayInicio = 1;</span>
			}
		}
<span class="fc" id="L722">		arrayFronterasEscalera[0] = arrayInicio;</span>
<span class="fc" id="L723">		arrayFronterasEscalera[1] = arrayFinal;</span>
		
<span class="fc" id="L725">		return arrayFronterasEscalera;</span>
	}
	
	/**
	 * Función auxiliar que ayuda a obtener la probabilidad de obtener una escalera de color con las cartas que tenemos
	 *
	 * @param numerosEscaleraColor Array con los números de las cartas que tenemos
	 * @param cartasPorMostrar Número de cartas que faltan por mostrar
	 * @param arrayInicio Índice del array por el cual comenzaremos a estudiar la escalera (Frontera Por Debajo)
	 * @param arrayFinal Índice del array por el cual terminaremos de estudiar la escalera (Frontera Por Encima)
	 * @return Probabilidad de obtener escalera de color con una carta específica de nuestra mano (double)
	 */
	private double probCompletarEscaleraColor( int[] numerosEscaleraColor, int cartasPorMostrar, int arrayInicio, int arrayFinal ){
<span class="fc" id="L738">		double prob = 0.0;</span>
		int numCartasNecesarias;
		int numCartasEscalera;
<span class="fc" id="L741">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">		for( int idx1 = arrayInicio ; idx1 &lt;= arrayFinal - 4 ; ++idx1 ) {</span>
<span class="fc" id="L743">			numCartasEscalera = 0;</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">			for( int idx = idx1 ; idx &lt;= idx1+4 ; ++idx) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">				if( numerosEscaleraColor[idx] == 1 ) {</span>
<span class="fc" id="L746">					++numCartasEscalera;</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">					if( numCartasEscalera &gt;= 5 ) {</span>
<span class="fc" id="L748">						return 1.0;</span>
					}
				}
			}
<span class="fc" id="L752">			numCartasNecesarias = 5 - numCartasEscalera;</span>
<span class="fc" id="L753">			prob += distribucionHiperGeometrica( numCartasNecesarias, numCartasNecesarias, cartasTotales,  cartasPorMostrar );</span>
		}
<span class="nc" id="L755">		return prob;</span>
	}

	/**
	 * Función que devuelve la probabilidad de obtener escalera real con las cartas que tenemos
	 *
	 * @param cartas Lista que contiene las cartas conocidas
	 * @return Probabilidad de obtener escalera real con las cartas de nuestra mano (double)
	 */
	private double completarEscaleraReal( List&lt;Carta&gt; cartas ){
		
<span class="fc" id="L766">		double prob = 0.0;</span>
<span class="fc" id="L767">		int numCartas = cartas.size();</span>
<span class="fc" id="L768">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L769">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
<span class="fc" id="L770">		int numCartasEscalera = 1;</span>
<span class="fc" id="L771">		boolean cartaMano1Posible = false;</span>
<span class="fc" id="L772">		boolean cartaMano2Posible = false;</span>
		
		// Para hacerlo más eficiente
<span class="fc" id="L775">		int inicioBucle = 1;</span>
<span class="fc" id="L776">		int topeBucle = 0;</span>
		
		/* Comprobamos las cartas de nuestra mano sean aptas para la escalera real*/
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">		if( cartas.get(0).getNumero() &gt;= 10 ) {</span>
<span class="fc" id="L780">			cartaMano1Posible = true;</span>
<span class="fc" id="L781">			inicioBucle = 0;</span>
		}
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">		if( cartas.get(1).getNumero() &gt;= 10 ) {</span>
<span class="fc" id="L784">			cartaMano2Posible = true;</span>
<span class="fc" id="L785">			topeBucle = 1;</span>
		}
		
<span class="pc bpc" id="L788" title="3 of 6 branches missed.">		if( cartas.get(0).mismoPaloQue( cartas.get(1)) &amp;&amp; cartaMano1Posible &amp;&amp; cartaMano2Posible) {</span>
<span class="fc" id="L789">			numCartasEscalera = 2;</span>
<span class="fc" id="L790">			topeBucle = 0;</span>
		}
		
<span class="fc bfc" id="L793" title="All 2 branches covered.">		for( int idxCartaMano = inicioBucle ; idxCartaMano &lt;= topeBucle ; ++idxCartaMano ) {</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">			for( int idxCartaMesa = 2; idxCartaMesa &lt; numCartas ; ++idxCartaMesa ) {</span>
<span class="fc" id="L795">				if( </span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">					cartas.get(idxCartaMesa).getNumero() &gt;= 10	&amp;&amp;</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">					cartas.get(idxCartaMano).mismoPaloQue(cartas.get(idxCartaMesa))			</span>
					) {
<span class="fc" id="L799">					++numCartasEscalera;	</span>
				}
			}
<span class="fc" id="L802">			int cartasNecesarias = 5 - numCartasEscalera;</span>
<span class="fc" id="L803">			prob += distribucionHiperGeometrica(cartasNecesarias,cartasNecesarias,cartasTotales, cartasPorMostrar);	/* Las cartas necesarias son las mismas, a las válidas */</span>
<span class="fc" id="L804">			numCartasEscalera = 1;</span>
		}
			
<span class="fc" id="L807">		return prob;</span>
	}
	
	/*
	 * ##############################################################################################################
	 * 								CALCULAR PROBABILIDAD DE LOS CONTRINCANTES
	 * ##############################################################################################################
	 */
	
	/** 
	 * Función que calcula la probabilidad de que uno de nuestro contrincantes obtengan una pareja o un trio o un poker con las cartas que conocemos
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @param numContrincantes número de contrincantes activos
	 * */
	private void completarParejaTrioPokerCont( List&lt;Carta&gt; cartas, int numContrincantes ) {
		
<span class="fc" id="L824">		int numCartas = cartas.size();</span>
		/* Si solo tenemos nuestrar cartas no calculamos nada de los contrincantes*/
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">		if( numCartas &lt; 3 ) {</span>
<span class="nc" id="L827">			this.probParejaCont = -1;</span>
<span class="nc" id="L828">			this.probTrioCont = -1;</span>
<span class="nc" id="L829">			this.probPokerCont = -1;</span>

		}
		else 
		{
<span class="fc" id="L834">			this.probParejaCont = 0;</span>
<span class="fc" id="L835">			this.probTrioCont = 0;</span>
<span class="fc" id="L836">			this.probPokerCont = 0;</span>
			
<span class="fc" id="L838">			int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L839">			int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
			int numCartasNecesarias;
<span class="fc" id="L841">			int numCartasValidasRestantes = 4;	/* Solo hay 4 cartas por número */</span>
			int numCartasQueYoTengo;
	
			Carta cartaAux;
			int cttCartasNumero;
			
			/* Rellenamos el Map */
<span class="fc" id="L848">			Map&lt; Integer , Integer&gt; contarCartas = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">			for( int idx = 2 ; idx &lt; numCartas ; ++idx ) {</span>
<span class="fc" id="L850">				cartaAux = cartas.get(idx);</span>
<span class="fc" id="L851">				cttCartasNumero = contarCartas.getOrDefault( cartaAux.getNumero(), 0) + 1;</span>
<span class="fc" id="L852">				contarCartas.put(cartaAux.getNumero(),cttCartasNumero);</span>
			}
			
<span class="fc bfc" id="L855" title="All 2 branches covered.">			for( Map.Entry&lt;Integer , Integer&gt; tupla : contarCartas.entrySet() ) {</span>
<span class="fc" id="L856">				numCartasQueYoTengo = 0;</span>
				/* Contamos las cartas de este tipo que tenemos */
<span class="fc bfc" id="L858" title="All 2 branches covered.">				for( int idx = 0 ; idx &lt; 2 ; ++idx ) {</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">					if( cartas.get(idx).getNumero() == tupla.getKey() ) {</span>
<span class="nc" id="L860">						++numCartasQueYoTengo;</span>
					}
				}
			
				/* Las cartas que no podemos ver y ayudarían a completar la mano */
<span class="fc" id="L865">				numCartasValidasRestantes = 4 - tupla.getValue() - numCartasQueYoTengo;</span>
				
				/* Las cartas que necesita el contrincante para conseguir una pareja */
<span class="fc" id="L868">				numCartasNecesarias  = 2 - tupla.getValue();</span>
<span class="fc" id="L869">				this.probParejaCont += distribucionHiperGeometrica(numCartasNecesarias, numCartasValidasRestantes,cartasTotales, cartasPorMostrar);</span>
				
				
				/* Las cartas que no podemos ver y ayudarían a completar el trio */
<span class="fc" id="L873">				numCartasNecesarias  = 3 - tupla.getValue();</span>
<span class="fc" id="L874">				this.probTrioCont += distribucionHiperGeometrica(numCartasNecesarias, numCartasValidasRestantes,cartasTotales, cartasPorMostrar);</span>
				
				
				/* Las cartas que no podemos ver y ayudarían a completar el poker */
<span class="fc" id="L878">				numCartasNecesarias  = 4 - tupla.getValue();</span>
<span class="fc" id="L879">				this.probPokerCont += distribucionHiperGeometrica(numCartasNecesarias, numCartasValidasRestantes,cartasTotales, cartasPorMostrar);</span>
				
<span class="fc" id="L881">			}</span>
		}
<span class="fc" id="L883">	}</span>
	
	/**
	 * Función que devuelve la probabilidad de que uno de nuestro contrincantes obtenegan color con las cartas que conocemos
	 * 
	 * @param cartas Lista que contiene las cartas conocidas
	 * @param numContrincantes Número de contrincantes activos
	 * @return Probabilidad de que un contrincante obtenga color con las cartas que conocemos (double)
	 */
	private double completarColorCont(List&lt;Carta&gt; cartas, int numContrincantes) {
		
<span class="fc" id="L894">		int numCartas = cartas.size();</span>
		/* Si solo tenemos nuestrar cartas no calculamos nada de los contrincantes*/
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">		if( numCartas &lt; 3 ) {</span>
<span class="nc" id="L897">			return -1;</span>
		}
<span class="fc" id="L899">		double prob = 0.0;</span>
<span class="fc" id="L900">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L901">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
		int numCartasNecesarias;
<span class="fc" id="L903">		int numCartasValidasRestantes = 13;</span>
		int numCartasQueYoTengo;
		
		int cttCartasColor;
		Carta cartaAux;
<span class="fc" id="L908">		Map&lt; Character , Integer&gt; contarCartas = new HashMap&lt;&gt;();</span>
		
<span class="fc bfc" id="L910" title="All 2 branches covered.">		for( int idx = 2 ; idx &lt; numCartas ; ++idx ) {</span>
<span class="fc" id="L911">			cartaAux = cartas.get(idx);</span>
<span class="fc" id="L912">            cttCartasColor = contarCartas.getOrDefault( cartaAux.getPalo(), 0) + 1;</span>
<span class="fc" id="L913">			contarCartas.put(cartaAux.getPalo(),cttCartasColor);</span>
		}
		
<span class="fc bfc" id="L916" title="All 2 branches covered.">		for( Map.Entry&lt;Character , Integer&gt; tupla : contarCartas.entrySet() ) {</span>
			
			/* Cuento las cartas que tengo de este color */
<span class="fc" id="L919">			numCartasQueYoTengo = 0;</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">			for( int idx = 0 ; idx &lt; 2 ; ++idx ) {</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">				if( cartas.get(idx).getPalo() == tupla.getKey() ) {</span>
<span class="fc" id="L922">					++numCartasQueYoTengo;</span>
				}
			}
			/* Las cartas que necesita el contrincante para conseguir color */
<span class="fc" id="L926">			numCartasNecesarias  = 5 - tupla.getValue();</span>
			
			/* Las cartas que no podemos ver y ayudarían a completar el color */
<span class="fc" id="L929">			numCartasValidasRestantes -= tupla.getValue() + numCartasQueYoTengo;</span>
			
<span class="fc bfc" id="L931" title="All 2 branches covered.">			for( int numCartasContrTendria = 0 ; numCartasContrTendria &lt; numCartasNecesarias ; ++numCartasContrTendria ) {</span>
<span class="fc" id="L932">				prob += distribucionHiperGeometrica(numCartasNecesarias, numCartasValidasRestantes,cartasTotales, cartasPorMostrar) *  distribucionHiperGeometrica(numCartasContrTendria, numCartasValidasRestantes,numContrincantes*2, cartasPorMostrar);</span>
				/* Esto esta raro, no me acuerdo lo que hace aquí */
			}
<span class="fc" id="L935">		}</span>
		
<span class="fc" id="L937">		return prob;</span>
	}
	
	private double completarEscaleraCont(List&lt;Carta&gt; cartas, int numContrincantes) {
		
<span class="fc" id="L942">		int numCartas = cartas.size();</span>
		/* Si solo tenemos nuestrar cartas no calculamos nada de los contrincantes*/
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">		if( numCartas &lt; 3 ) {</span>
<span class="nc" id="L945">			return -1;</span>
		}
<span class="fc" id="L947">		double prob = 0.0;</span>
<span class="fc" id="L948">		int cartasPorMostrar = MAX_CARTAS_VISIBLES - numCartas;</span>
<span class="fc" id="L949">		int cartasTotales = NUM_CARTAS_NUNCA_VES + cartasPorMostrar;</span>
		//int numCartasNecesarias;
		//int numCartasValidas = 13;
		//int numCartasQueYoTengo;
		
		
<span class="fc" id="L955">		int[] numerosEscaleraCont = new int[15];</span>
		
<span class="fc bfc" id="L957" title="All 2 branches covered.">		for( int idx = 2; idx &lt; numCartas ; ++idx ) {</span>
<span class="fc" id="L958">			numerosEscaleraCont[ cartas.get(idx).getNumero() ] = 1;</span>
		}
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">		if( numerosEscaleraCont[14] == 1 ) {	// Está el AS, 14-1=13</span>
<span class="nc" id="L961">			numerosEscaleraCont[1] = 1;</span>
		}
		
		/* Calculamos los límites de la baraja que debemos estudiar */
		
<span class="fc" id="L966">		return prob;</span>
	}
	
	private double completarFullHouseCont(List&lt;Carta&gt; cartas, int numContrincantes) {
<span class="fc" id="L970">		return 0.0;</span>
	}
	
	private double completarEscaleraColorCont(List&lt;Carta&gt; cartas, int numContrincantes) {
<span class="fc" id="L974">		return 0.0;</span>
	}
	
	private double completarEscaleraRealCont(List&lt;Carta&gt; cartas, int numContrincantes) {
<span class="fc" id="L978">		return 0.0;</span>
	}
	
	/*
	 * ##############################################################################################################
	 * 												TOMA DE DECISIONES
	 * ##############################################################################################################
	 */

	/**
	 * 
	 * @param ciegaPequenya Valor de la ciega pequenya de la mano
	 * @param apuestaAcumulada Valor de la apuesta acumulada en la mano
	 * 
	 * @return Clase que define la decisión que debe tomar el jugador
	 */
	private Decision calcularDecision(int ciegaPequenya, int apuestaAcumulada) {
		
<span class="fc" id="L996">		Decision decision = new Decision();</span>
		
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">		if( probEscaleraReal == 1.0 ) {				/* JUGADOR TIENE ESCALERA REAL (Mejor mano posible, no la puede tener nadie a la vez) */</span>
<span class="fc" id="L999">			decision.setDecision( Decision.ALL_IN );</span>
<span class="nc bnc" id="L1000" title="All 4 branches missed.">		}else if( probEscaleraColor == 1.0 &amp;&amp; probEscaleraColorCont != 1.0) {</span>
<span class="nc" id="L1001">			decision.setDecision( Decision.ALL_IN );</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">		}else if( probPoker == 1.0 ) {</span>
<span class="nc" id="L1003">			decision.setDecision( Decision.ALL_IN );</span>
		}
		
		
<span class="fc" id="L1007">		return decision;</span>
	}
	
	
	/*
	 * ##############################################################################################################
	 * 									FUNCIONES PARA CALCULAR PROBABILIDAD 
	 * ##############################################################################################################
	 */
	
	/**
	 * Esta función usa la distribución hipergeométrica para obtener la probabilidad de obtener una determinada mano
	 * 
	 * @param cartasNecesarias El número de cartas que necesitamos para completar nuestra mano
	 * @param cartasValidasRestantes El número de cartas de ese tipo que nos sirven para completar la mano
	 * @param cartasTotales El número de cartas totales que no han salido todavía
	 * @param cartasPorMostrar El número de cartas que faltan por desvelar 
	 * 
	 * @return La probabilidad de que la mano se complete
	 */
	private double distribucionHiperGeometrica( int cartasNecesarias, int cartasValidasRestantes, int cartasTotales, int cartasPorMostrar) {
		double prob;
<span class="fc bfc" id="L1029" title="All 2 branches covered.">		if( cartasNecesarias &lt;= 0 ) {</span>
<span class="fc" id="L1030">			prob = 1.0;</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">		}else if( cartasNecesarias &gt; cartasPorMostrar ) {</span>
<span class="fc" id="L1032">			prob = 0.0;</span>
		}else{
<span class="fc" id="L1034">			int combinacionesPosibles = C( cartasTotales , cartasPorMostrar );</span>
<span class="fc" id="L1035">			int combinacionesFormasSalirCartasNecesarias = C( cartasValidasRestantes , cartasNecesarias );</span>
<span class="fc" id="L1036">			int combinacionesDemasCartas = C( cartasTotales - cartasValidasRestantes, cartasPorMostrar - cartasNecesarias);</span>
			
<span class="fc" id="L1038">			prob = (double) (combinacionesFormasSalirCartasNecesarias * combinacionesDemasCartas) / combinacionesPosibles;</span>
		}
		
<span class="fc" id="L1041">		return prob;</span>
	}
	
	/**
	 * Esta función usa la distribución binomial para obtener la probabilidad de obtener una determinada mano
	 * 
	 * @param cartasNecesarias El número de cartas que necesitamos para completar nuestra mano
	 * @param cartasPorMostrar El número de cartas que faltan por desvelar 
	 * 
	 * @deprecated
	 * 
	 * @return La probabilidad de que la mano se complete
	 */
	private double distribucionBinomial(int cartasNecesarias, int cartasPorMostrar) {
		
<span class="nc" id="L1056">		int cartasQueNoHanSalido = 45 + cartasPorMostrar;			//N = cartasQueNoHanSalido ; K = Cartas Necesarias</span>
		
<span class="nc" id="L1058">		long combinacionesNK = C(cartasQueNoHanSalido, cartasNecesarias);</span>
<span class="nc" id="L1059">		double p = cartasNecesarias / cartasQueNoHanSalido;</span>
		
<span class="nc" id="L1061">		return (double) combinacionesNK * Math.pow(p, cartasNecesarias) * Math.pow(1.0-p, cartasQueNoHanSalido-cartasNecesarias);</span>
	}
	
	
	/**
	 * Obtenemos la probabilidad de obtener un determinado número de cartas, en un conjunto donde tenemos un numero de cartas válidas y del cual solo podemos tomar un número límitado de estas
	 *
	 * @deprecated
	 *
	 * @param numCartasValidas número de cartas del conjunto que son válidas para el individuo
	 * @param numCartasPosibles número de cartas diferentes que podemos tomar
	 * @param iteraciones número de cartas que posee el conjunto con el que trabajamos
	 * @param numCartasNecesarias número de cartas del conjunto de cartas válidas que necesitamos
	 * 
	 */
	private double probabilidadComplementaria( int numCartasValidas, int numCartasPosibles, int iteraciones, int numCartasNecesarias) {
<span class="nc" id="L1077">		double prob = 1.0;</span>
		
		int numCartasPosiblesAux;
		int numCartasValidasAux;
		
<span class="nc bnc" id="L1082" title="All 4 branches missed.">		if( numCartasNecesarias &lt;= 2 &amp;&amp; numCartasNecesarias &gt; 0) {</span>
			
<span class="nc bnc" id="L1084" title="All 2 branches missed.">			for( int co = 0 ; co &lt; numCartasNecesarias ; co++ ) {	// co = cartas que obtienes</span>

<span class="nc bnc" id="L1086" title="All 2 branches missed.">				for( int io = 0 ; io &lt; numCartasNecesarias ; io++ ) {	// io = iteracion donde obtiene la carta</span>

<span class="nc" id="L1088">					numCartasValidasAux = numCartasValidas;</span>
<span class="nc" id="L1089">					numCartasPosiblesAux = numCartasPosibles;</span>
					
<span class="nc bnc" id="L1091" title="All 2 branches missed.">					for( int i = 0 ; i &lt; iteraciones ; ++i ) {</span>
						
<span class="nc bnc" id="L1093" title="All 4 branches missed.">						if( i == io &amp;&amp; co &gt; 0  ) {</span>
<span class="nc" id="L1094">							prob *= (double) numCartasValidasAux / numCartasPosiblesAux;</span>
<span class="nc" id="L1095">							--numCartasValidasAux;</span>
						}else {
<span class="nc" id="L1097">							prob *=  1.0 -  ((double) numCartasValidasAux / numCartasPosiblesAux);</span>
<span class="nc" id="L1098">							--numCartasPosiblesAux;</span>
						}
						
					}
				}
			}
			
<span class="nc" id="L1105">			prob = 1.0 - prob;</span>
			
<span class="nc bnc" id="L1107" title="All 2 branches missed.">		}else if( numCartasNecesarias &gt; 0) {	// Es mejor cambiar el método para estos casos para no elevar mucho la complejidad del algoritmo</span>
			
			
			
		}
		
<span class="nc" id="L1113">		return prob;</span>
	}

	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>